#!/usr/bin/env bash
# shellcheck disable=SC1091

# Path -----------------------------------------------------

__deduplicate_path() {
  # https://unix.stackexchange.com/a/124517
  printf %s "$PATH" | awk -v RS=: '!a[$0]++' | paste -s -d: -
}

[[ $(type -t brew) ]] && PATH="$(brew --prefix)/bin:$(brew --prefix)/sbin:$PATH"
[[ -d $HOME/bin ]] && PATH="$HOME/bin:$PATH"

PATH=$(__deduplicate_path "$PATH")
export PATH

# Exports --------------------------------------------------
# Many from https://github.com/mathiasbynens/dotfiles/

# Editor preference, in order
__get_editor() {
  [[ $(type -p code) ]] && echo "code -w" && return 0
  [[ $(type -p vim) ]]  && echo "vim"     && return 0
  [[ $(type -p vi) ]]   && echo "vi"      && return 0
  [[ $(type -p nano) ]] && echo "nano"    && return 0
  return 1
}

EDITOR=$(__get_editor)
export EDITOR
export VISUAL=$EDITOR

# Increase Bash history size. Allow 32³ entries; the default is 500.
export HISTSIZE="32768"
export HISTFILESIZE="${HISTSIZE}"
# Omit duplicates and commands that begin with a space from history.
export HISTCONTROL="ignoreboth"

# Prefer US English and use UTF-8.
export LANG="en_US.UTF-8"
export LC_ALL="en_US.UTF-8"

# Don’t clear the screen after quitting a manual page.
export MANPAGER="less -X"

# Avoid issues with `gpg` as installed via Homebrew.
# https://stackoverflow.com/a/42265848
GPG_TTY=$(tty)
export GPG_TTY

# Homebrew defaults
if [[ $(type -t brew) ]]; then
  export HOMEBREW_NO_ANALYTICS=1
  export HOMEBREW_NO_ENV_HINTS=1
fi

# Completion -----------------------------------------------

# Bash completions
# Cf https://github.com/mathiasbynens/dotfiles/blob/main/.bash_profile
if [[ -f /etc/bash_completion ]]; then
  source /etc/bash_completion
fi

# Some systems have bash completions installed here
if [[ -f /usr/share/bash-completion/bash_completion ]]; then
  source /usr/share/bash-completion/bash_completion
fi

# ubuntu, debian, and centos have a bunch of scripts here
if [[ -d /usr/share/bash-completion/completions ]]; then
  for f in /usr/share/bash-completion/completions/*; do
    # shellcheck source=/dev/null
    source "$f" 2>/dev/null
  done
fi

if which brew &> /dev/null && [[ -r "$(brew --prefix)/etc/profile.d/bash_completion.sh" ]]; then
  # Ensure existing Homebrew v1 completions continue to work
  BASH_COMPLETION_COMPAT_DIR="$(brew --prefix)/etc/bash_completion.d"
  export BASH_COMPLETION_COMPAT_DIR

  # shellcheck source=/dev/null
  source "$(brew --prefix)/etc/profile.d/bash_completion.sh"
fi

# Add tab completion for SSH hostnames based on ~/.ssh/config, ignoring wildcards
# https://github.com/mathiasbynens/dotfiles/blob/main/.bash_profile
if [[ -e $HOME/.ssh/config ]]; then
  ssh_complete_hosts_=$(grep "^Host" ~/.ssh/config | grep -v "[?*]" | cut -d " " -f2- | tr ' ' '\n')
  complete -o "default" -o "nospace" -W "$ssh_complete_hosts_" scp sftp ssh
  unset ssh_complete_hosts_
fi

# Prompt ---------------------------------------------------
# https://superuser.com/q/1619614

# Turn /Users/tshafer/somedir/someotherdir -> ~/s/someotherdir
__trunc_pwd() {
  pwd | sed -r -e "s:$HOME:~:" -e 's:([^/])([^/]+/):\1/:g'
}

# Custom, simple Git prompt
__git_prompt() {
  if [[ $(type -t __git_ps1) ]]; then
    __git_ps1 " %s"
  else
    if [[ $(type -p git) && $(git rev-parse --is-inside-work-tree 2> /dev/null) ]]; then
      # https://github.com/mathiasbynens/dotfiles/
      # Check for what branch we’re on. Get the short
      # symbolic ref. If HEAD isn’t a symbolic ref, get a
      # tracking remote branch or tag. Otherwise, get the
      # short SHA for the latest commit, or give up.
      echo " $(
        git symbolic-ref --quiet --short HEAD 2> /dev/null \
          || git describe --all --exact-match HEAD 2> /dev/null \
          || git rev-parse --short HEAD 2> /dev/null \
          || echo '(unknown)'
      )"
    fi
  fi
}

# Add a virtualenv marker if active
__venv_prompt() {
  [[ -n $VIRTUAL_ENV ]] && printf ' (%s)' "$(basename "$VIRTUAL_ENV")"
}

# Add a conda marker if active and not the base env
__conda_prompt() {
  if [[ -n $CONDA_PROMPT_MODIFIER && -z $VIRTUAL_ENV ]]; then
    # shellcheck disable=SC2001
    echo "$CONDA_PROMPT_MODIFIER" | sed -e 's:^.*\(base\).*$::'
  fi
}

# Set the terminal title
__term_title() {
  # https://askubuntu.com/a/143514
  echo -ne "\033]0;$(pwd) ($(whoami)@$(hostname -s))\007"
}

# This runs and sets PS1 for every new prompt
__prompt_command() {
  _pre=$([[ -n $PS1_PREFIX ]] && echo "$PS1_PREFIX ")
  _git=$(__git_prompt)
  _pwd=$(__trunc_pwd)
  _env=$(__venv_prompt)
  _conda=$(__conda_prompt)

  # Update history: https://askubuntu.com/a/80380
  history -a

  # Colors
  local path_color="\e[0;32m"
  local git_color="\e[0;33m"

  [[ -n $PS1_COLOR_PATH ]] && path_color="$PS1_COLOR_PATH"
  [[ -n $PS1_COLOR_GIT ]] && git_color="$PS1_COLOR_GIT"

  __term_title

  PS1='$_pre$_conda'
  PS1+="\[$path_color\]"
  PS1+='$_pwd'
  PS1+="\[\e[0m\]\[$git_color\]"
  PS1+='$_git\[\e[0m\]$_env \$ '
}

PROMPT_COMMAND=__prompt_command

# Aliases --------------------------------------------------

alias ..='cd ..'
alias ...='cd ../..'
alias -- -='cd -'
alias cn=coden

# Alias g <=> git and enable completion
alias g='git'
if [[ $(type -t __git_complete) ]]; then
  __git_complete g __git_main
fi

# MacOS only: Use 'open' to open GUI apps and the Finder
if [[ -n $(type -p open) ]]; then
  alias o='command open'
  alias oo='o .'
  alias rstudio='command open -a RStudio'
  alias st='command open -a SourceTree'
fi

# Directory listings -- I prefer 'exa' if I have it
if [[ -n $(type -p exa) ]]; then
  function __redef_ls {
    exa -Fg \
        --no-permissions \
        --octal-permissions \
        --color-scale \
        --group-directories-first \
        --git \
        "$@"
  }

  function l  { __redef_ls -l          "$@"; }
  function ll { l          -a          "$@"; }
  function la { l          -aa         "$@"; }
  function lr { l          --sort=date "$@"; }
  function lt { lr         --reverse   "$@"; }
else
  function __redef_ls {
    ls -Fh --color=auto "$@"
  }

  function l  { __redef_ls -l "$@"; }
  function ll { l          -A "$@"; }
  function la { l          -a "$@"; }
  function lt { l          -r "$@"; }
  function lr { lt         -t "$@"; }
fi

# Within-shell functions -----------------------------------

# Activate a local virtual environment
venv() {
  local venv_dirs=(venv .venv)
  local quiet=0

  # Show help
  [[ $# -gt 1 || $1 =~ "-h" ]] && echo >&2 "Usage: venv [-q]" && return 0

  # Set quiet flag
  [[ $1 =~ "-q" ]] && quiet=1

  # Find and activate the first virtualenv
  local matched=0
  for d in "${venv_dirs[@]}"; do
    if [[ -f $d/bin/activate ]]; then
      # shellcheck source=/dev/null
      source "$d/bin/activate"
      matched=1
      break
    fi
  done

  unset _usage

  # Print Python path(s)
  if [[ $matched == 1 ]]; then
    [[ $quiet == 0 ]] && {
      which python
      which pip
    }
    return 0
  fi

  [[ $quiet == 0 ]] && echo >&2 'No virtualenv found'
  return 1
}

# Copy pwd to clipboard
cpwd() {
  __error() {
    echo >&2 "Command 'pbcopy' is not available"
  }

  [[ -z $(type -p pbcopy) ]] && __error && return 1
  pwd | tr -d '\n' | pbcopy
}

# Run mkdir and cd together
mkd() {
  [[ $# != 1 ]] && echo >&2 "Usage: mkd DIRECTORY" && return 1
  mkdir -p "$1" && cd "$1" && echo >&2 "mkdir \"$1\""
}

# Find open an RStudio project file in a given directory
rproj() {
  [[ $# -gt 1 ]] && echo >&2 "Usage: rproj [DIR]" && return 1

  local lsdir rproj
  lsdir=$([[ $# -eq 0 ]] && pwd || echo "$1")
  rproj=$(find "$lsdir" -type f -iname '*.rproj' | sort | head -n 1)
  [[ ! $rproj ]] && echo >&2 "No .Rproj files found at $lsdir" && return 1

  command=(open -a RStudio "$(basename "$rproj")")
  echo "${command[@]}" >&2
  "${command[@]}"
}

# Make a new RStudio project
mkrproj() {
  if [[ $# -gt 1 ]]; then
    >&2 echo "Error: Only one input is supported."
    >&2 echo "Usage: mkrproj [DIR]"
    return 1
  fi

  local path
  path=$([[ $# -eq 0 ]] && echo '.' || echo "$1")

  bash -x -c "Rscript -e \"usethis::create_project(path = '$path', rstudio = TRUE)\"" && \
  bash -x -c "touch '$path/.here'" && \
  bash -x -c "rmdir '$path/R'" && \
  cd "$path" || return
}

# Get a random integer from random.org
mkrand() {
  curl "https://www.random.org/integers/?num=1&min=1&max=10000000&col=1&base=10&format=plain&rnd=new"
  return 0
}

# Open man page in a GUI
mn() {
  # https://unix.stackexchange.com/a/466486
  if [[ $(type -t open) ]]; then
    # https://stackoverflow.com/a/31424574
    mp=$(man "$@") && echo "$mp" | col -b | open -a TextEdit -f
  else
    >&2 echo "falling back to 'man'"
    man "$@"
  fi
}

# Extend the completion
complete -F _man mn

# Open a new VS Code window, maybe in the current directory
coden() {
  local dest
  dest=$(if [[ $# -eq 0 ]]; then echo "."; else echo "$@"; fi)
  echo "code -n $dest" >&2
  code -n "$dest"
}

# Compare a file's MD5 checksum to a known value
checkmd5sum() {
  local original_checksum

  _usage() {
    echo >&2 "Usage: checkmd5sum -c <checksum> <file>"
  }

  OPTIND=1  # https://unix.stackexchange.com/a/430339

  while getopts "hc:" opt; do
    case "${opt}" in
      c)
        original_checksum="$OPTARG"
        ;;
      *)
        _usage
        return 0
        ;;
    esac
  done

  shift $((OPTIND-1))
  [[ $# -ne 1 ]] && _usage && return 1
  [[ -z $original_checksum ]] && _usage && return 1

  # Compute the checksum
  if [[ $(type -t md5) ]]; then
    checksum=$(md5 -q "$1")
  elif [[ $(type -t md5sum) ]]; then
    checksum=$(md5sum "$1" | cut -d " " -f 1)
  else
    echo >&2 "Neither md5 nor md5sum found on this machine."
    return 1
  fi

  checksum=$(md5 -q "$1")
  if [[ "$checksum" != "$original_checksum" ]]; then
    echo   >&2 "Checksums do not match:"
    printf >&2 "  %s (input)\n" "$original_checksum"
    printf >&2 "  %s (file)\n"  "$checksum"
    return 1
  fi

  echo >&2 "✔︎ Checksums OK"
  return 0
}
