
IS_MACOSX=$([[ `uname -s` =~ ^Darwin ]] && echo 1)


# Path -----------------------------------------------------

__deduplicate_path() {
    # https://unix.stackexchange.com/a/124517
    printf %s "$PATH" | awk -v RS=: '!a[$0]++' | paste -s -d: -
}

[[ `type -t brew` ]] && PATH="$(brew --prefix)/bin:$(brew --prefix)/sbin:$PATH"
[[ -d $HOME/bin ]] && PATH="$HOME/bin:$PATH"
export PATH=$(__deduplicate_path "$PATH")


# Exports --------------------------------------------------
# Many from https://github.com/mathiasbynens/dotfiles/

export EDITOR="$([[ `type -p code` ]] && echo code -w || echo vim)"
export VISUAL="$EDITOR"

# Increase Bash history size. Allow 32³ entries; the default is 500.
export HISTSIZE='32768'
export HISTFILESIZE="${HISTSIZE}"
# Omit duplicates and commands that begin with a space from history.
export HISTCONTROL='ignoreboth'

# Prefer US English and use UTF-8.
export LANG='en_US.UTF-8'
export LC_ALL='en_US.UTF-8'

# Don’t clear the screen after quitting a manual page.
export MANPAGER='less -X'

# Avoid issues with `gpg` as installed via Homebrew.
# https://stackoverflow.com/a/42265848
export GPG_TTY=$(tty)


# Completion -----------------------------------------------

# Bash completions
# Cf https://github.com/mathiasbynens/dotfiles/blob/main/.bash_profile
if [[ -f /etc/bash_completion ]]; then
    source /etc/bash_completion;
fi

if which brew &> /dev/null && [ -r "$(brew --prefix)/etc/profile.d/bash_completion.sh" ]; then
	# Ensure existing Homebrew v1 completions continue to work
	export BASH_COMPLETION_COMPAT_DIR="$(brew --prefix)/etc/bash_completion.d";
	source "$(brew --prefix)/etc/profile.d/bash_completion.sh";
fi

# Add tab completion for SSH hostnames based on ~/.ssh/config, ignoring wildcards
# https://github.com/mathiasbynens/dotfiles/blob/main/.bash_profile
if [[ -e $HOME/.ssh/config ]]; then
    complete \
        -o "default" \
        -o "nospace" \
        -W "$(grep "^Host" ~/.ssh/config | grep -v "[?*]" | cut -d " " -f2- | tr ' ' '\n')" \
        scp sftp ssh;
fi


# Prompt ---------------------------------------------------
# https://superuser.com/q/1619614

__trunc_pwd() {
    # Turn /Users/tshafer/somedir/someotherdir -> ~/s/someotherdir
    pwd | sed -r -e "s:$HOME:~:" -e 's:([^/])([^/]+/):\1/:g'
}

__git_prompt() {
    if [[ `type -t __git_ps1` ]]; then

        __git_ps1 " %s"

    else

        if [[ `type -p git` && `git rev-parse --is-inside-work-tree 2>/dev/null` ]]; then

            # https://github.com/mathiasbynens/dotfiles/
            # Check for what branch we’re on. Get the short
	        # symbolic ref. If HEAD isn’t a symbolic ref, get a
	        # tracking remote branch or tag. Otherwise, get the
	        # short SHA for the latest commit, or give up.
	        echo " $(
                git symbolic-ref --quiet --short HEAD 2> /dev/null || \
                    git describe --all --exact-match HEAD 2> /dev/null || \
		            git rev-parse --short HEAD 2> /dev/null || \
		            echo '(unknown)'
            )"

        fi

    fi
}

__venv_prompt() {
  [[ -n $VIRTUAL_ENV ]] && printf ' (%s)' `basename $VIRTUAL_ENV`
}

__conda_prompt() {
    if [[ -n $CONDA_PROMPT_MODIFIER && -z $VIRTUAL_ENV ]]; then
        echo "$CONDA_PROMPT_MODIFIER" | sed -e 's:^.*\(base\).*$::'
    fi
}

__term_title() {
    # https://askubuntu.com/a/143514
    echo -ne "\033]0;$(pwd) ($(whoami)@$(hostname -s))\007"
}

__prompt_command() {
    _pre=$([[ -n $PS1_PREFIX ]] && echo "$PS1_PREFIX ")
    _git=$(__git_prompt)
    _pwd=$(__trunc_pwd)
    _env=$(__venv_prompt)
    _conda=$(__conda_prompt)

    __term_title
    PS1='$_pre$_conda\[\e[0;32m\]$_pwd\[\e[0m\]\[\e[0;33m\]$_git\[\e[0m\]$_env \$ '
}

PROMPT_COMMAND=__prompt_command


# Aliases --------------------------------------------------

alias ..='cd ..'
alias -- -='cd -'

# MacOS only
if [[ -n $IS_MACOSX ]]; then
    alias o='command open'
    alias oo='o .'
    alias rstudio='command open -a rstudio'
    alias st='command open -a sourcetree'
fi

# Directory listings -- I prefer 'exa' if I have it
if [[ -n `type -p exa` ]]; then

    alias ls='exa --no-permissions --octal-permissions --color-scale --group-directories-first --git -Fg'

    alias l='ls -l'
    alias ll='l -a'
    alias la='ll -a'
    alias lr='l --sort=date'
    alias lt='lr --reverse'

else

    # MacOS has a different set of arguments for ls.
    colorflag=$(ls --color &>/dev/null && echo "--color" || echo "-G")

    alias ls="command ls -Fh $colorflag"
    alias l='ls -l'
    alias ll='l -Ak'
    alias la='l -a'
    alias lt='l -r'
    alias lr='lt -t'

fi


# Functions ------------------------------------------------

mkd() {
    # mkdir + cd together
    if [[ $# != 1 ]]; then
        >&2 echo 'Error: mkd only supports one path'
        return 1
    fi
    mkdir -p "$1" && cd "$1" && echo "mkdir '$1'"
}

cpwd() {
    # Copy pwd to clipboard
    if [[ -z `type -p pbcopy` ]]; then
        >&2 echo "Command 'pbcopy' is not available."
        return 1
    fi
    pwd | tr -d '\n' | pbcopy
}

venv() {
    # Source venv in the current directory
    local dir_options=(.venv venv .env env)
    local matched=0
    for d in "${dir_options[@]}"; do
        if [[ -f $d/bin/activate ]]; then
            source "$d/bin/activate"
            matched=1
            break
        fi
    done

    if [[ $matched == 1 ]]; then
        which python
        which pip
    else
        >&2 echo 'No virtualenv found.'
    fi

    unset dir_options matched
}

rproj() {
    if [[ $# -gt 1 ]]; then
        >&2 echo "Usage: rproj [DIR]"
        break
    fi
    local lsdir=$([[ $# -eq 0 ]] && echo "." || echo "$1")
    local lspath="`ls $lsdir/*.Rproj | awk '{print $1;}'`"
    >&2 echo "Opening $lspath"
    open -a rstudio "$lspath"
}


# Cleanup --------------------------------------------------

unset IS_MACOSX
