# shellcheck shell=bash
# shellcheck disable=SC1091
# shellcheck disable=SC1090

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/../common/realpath.sh"
DOTFILES_DIR="$(resolve_realpath "$SCRIPT_DIR/../../")"
unset SCRIPT_DIR

# Only interactive -----------------------------------------

case $- in
*i*) ;;
*) return ;;
esac

# Bash options ---------------------------------------------

shopt -s autocd 2>/dev/null
shopt -s cdspell
shopt -s checkwinsize
shopt -s dirspell 2>/dev/null
shopt -s globstar 2>/dev/null
shopt -s no_empty_cmd_completion 2>/dev/null
shopt -s nocaseglob
set -o noclobber

# Common setup ---------------------------------------------

source "$DOTFILES_DIR/shell/common/path.sh"
source "$DOTFILES_DIR/shell/common/exports.sh"
source "$DOTFILES_DIR/shell/common/aliases.sh"
source "$DOTFILES_DIR/shell/common/functions.sh"

# Completion -----------------------------------------------

# Custom completions for common directories
complete -d cd pushd rmdir

# Homebrew completions
if command -v brew >/dev/null; then
    if [[ -r $(brew --prefix)/etc/profile.d/bash_completion.sh ]]; then
        source "$HOMEBREW_PREFIX/etc/profile.d/bash_completion.sh"
    fi

    if [[ -f $(brew --prefix)/etc/bash_completion.d/brew ]]; then
        source "$(brew --prefix)/etc/bash_completion.d/brew"
    fi
fi

# SSH hostname completion from known_hosts and config
_ssh_hosts() {
    local hosts=""
    if [[ -f ~/.ssh/config ]]; then
        hosts=$(awk '/^[[:space:]]*Host[[:space:]]/ {
            for(i=2; i<=NF; i++)
                if($i !~ /[*?!]/ && $i != "")
                    print $i
        }' ~/.ssh/config)
    fi

    COMPREPLY=()
    local completions
    completions=$(compgen -W "$hosts" -- "${COMP_WORDS[COMP_CWORD]}")

    local IFS=$'\n'
    for completion in $completions; do
        COMPREPLY+=("$completion")
    done
}
complete -F _ssh_hosts ssh scp sftp

# Git completion
if ! declare -F _git >/dev/null 2>&1; then
    for git_completion in \
        "/opt/homebrew/etc/bash_completion.d/git-completion.bash" \
        "/usr/share/bash-completion/completions/git" \
        "/etc/bash_completion.d/git"; do
        if [[ -f "$git_completion" ]]; then
            source "$git_completion"
            break
        fi
    done
fi
unset git_completion

# Git prompt
if ! declare -F __git_ps1 >/dev/null 2>&1; then
    for git_prompt in \
        "/opt/homebrew/etc/bash_completion.d/git-prompt.sh" \
        "/usr/share/git/completion/git-prompt.sh" \
        "/etc/bash_completion.d/git-prompt.sh"; do
        if [[ -f "$git_prompt" ]]; then
            source "$git_prompt"
            break
        fi
    done
fi
unset git_prompt

# Common tools ---------------------------------------------

source "$DOTFILES_DIR/shell/common/tools.sh"

# History configuration ------------------------------------

shopt -s histappend
shopt -s histverify

export HISTFILE="$HOME/.bash_history"

export HISTTIMEFORMAT="%F %T "

export HISTSIZE=100000     # 100,000 commands in memory
export HISTFILESIZE=500000 # 500,000 commands on disk

# Ignore commands starting with spaces and duplicates
# Remove previous duplicates when new ones are added
export HISTCONTROL="ignoreboth:erasedups"

# Ignore common commands
export HISTIGNORE="ls:ll:la:cd:pwd:clear:history:exit"

# Immediate history sync
history_sync_cmd="history -a; history -n"
if [[ ${PROMPT_COMMAND-} != *"$history_sync_cmd"* ]]; then
    if [[ -n ${PROMPT_COMMAND-} ]]; then
        PROMPT_COMMAND="$history_sync_cmd; $PROMPT_COMMAND"
    else
        PROMPT_COMMAND="$history_sync_cmd"
    fi
fi

exit_status_cmd='__DOTFILES_LAST_STATUS=$?'
if [[ $PROMPT_COMMAND != *"$exit_status_cmd"* ]]; then
    PROMPT_COMMAND="$exit_status_cmd; $PROMPT_COMMAND"
fi
export PROMPT_COMMAND
unset history_sync_cmd exit_status_cmd

# History file permissions
touch "$HISTFILE" 2>/dev/null
chmod 600 "$HISTFILE" 2>/dev/null

# Prompt ---------------------------------------------------

blue=$(tput setaf 4)
magenta=$(tput setaf 5)
yellow=$(tput setaf 3)
yellow_bg=$(tput setab 3)
black=$(tput setaf 0)
reset=$(tput sgr0)

export PROMPT_DIRTRIM="${TRS_PS1_NUM_DIRS:-1}"

git_prompt=""
if declare -F __git_ps1 >/dev/null 2>&1; then
    export GIT_PS1_SHOWDIRTYSTATE=1
    git_prompt="\\[$magenta\\]\$(__git_ps1 ' (%s)')\\[$reset\\]"
fi

status_color="\\[$reset\\]"
if [[ ${__DOTFILES_LAST_STATUS:-0} -ne 0 && ${__DOTFILES_LAST_STATUS:-0} -ne 130 ]]; then
    status_color="\\[$yellow\\]"
fi

PS1="${TRS_PS1_LABEL:+"$TRS_PS1_LABEL "}\[$blue\]\w\[$reset\]${git_prompt} ${status_color}${TRS_PS1_ICON:-\$}\\[$reset\\] "
export PS1

unset blue magenta yellow yellow_bg black reset git_prompt status_color

# Local overrides ------------------------------------------

if [[ -z ${DOTFILES_LOCAL_LOADED-} ]]; then
    DOTFILES_LOCAL_LOADED=1
    dotfiles_local="${XDG_CONFIG_HOME:-$HOME/.config}/dotfiles/local.sh"
    [[ -r $dotfiles_local ]] && source "$dotfiles_local"
    unset dotfiles_local
fi
